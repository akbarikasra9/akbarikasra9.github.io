<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Assignment 2: Prompt exercise – Kasra Akbari</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-acb86da7cc94e534617b9af23b514896.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Kasra Akbari</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assignments-for-data-methods" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assignments for Data Methods</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assignments-for-data-methods">    
        <li>
    <a class="dropdown-item" href="./assign01.html">
 <span class="dropdown-text">Assignment 1: Creating a Quarto Website</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign02.html">
 <span class="dropdown-text">Assignment 2: Google Trends Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign03.html">
 <span class="dropdown-text">Assignment 3: Mapping Census Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign04.html">
 <span class="dropdown-text">Assignment 4: Webscraping 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign05.html">
 <span class="dropdown-text">Assignment 5: Government Data API</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign06p1.html">
 <span class="dropdown-text">Assignment 6: Quanteda Text Analysis Part 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign06p2.html">
 <span class="dropdown-text">Assignment 6: Quanteda Text Analysis Part 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./podcast.html">
 <span class="dropdown-text">Podcast Review</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assignments-for-knowledge-mining" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assignments for Knowledge Mining</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assignments-for-knowledge-mining">    
        <li>
    <a class="dropdown-item" href="./assignment1.html">
 <span class="dropdown-text">Assignment 1: Brush Up R and Quarto</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assignment2.html">
 <span class="dropdown-text">Assignment 2: Prompt exercise</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./weeklyreflection1.html">
 <span class="dropdown-text">Weekly Reflections</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-assignments-for-information-management" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Assignments for Information Management</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-assignments-for-information-management">    
        <li>
    <a class="dropdown-item" href="./assign1.html">
 <span class="dropdown-text">Assignment 1: Information Management Applications and Database Systems</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assign2.html">
 <span class="dropdown-text">Assignment 2: Relational Schema and Database Concepts</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cvresume" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">CV/Resume</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-cvresume">    
        <li>
    <a class="dropdown-item" href="./resume2025.html">
 <span class="dropdown-text">Resume 2026</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Assignment 2: Prompt exercise</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<ul>
<li><p><strong>Step 1: Initial Prompt Creation</strong></p>
<ul>
<li>Task: Write a baseline prompt to request a structured systematic literature review on data mining and machine learning applications.</li>
<li>Prompt: “Conduct a 2,500-word structured systematic literature review on the applications of data mining and machine learning in real-world domains. Include a methodology section, synthesize key findings, identify trends and gaps, and propose one testable hypothesis. Use an academic tone and emulate systematic review standards.”</li>
<li>I submit this prompt to ChatGPT, Copilot, and Grok 3, collecting the raw outputs.</li>
</ul></li>
<li><p><strong>Step 2: Analyze Model Responses</strong></p>
<ul>
<li><strong>Structure</strong>: Did it include a methodology section and follow a systematic review format?
<ul>
<li><strong>ChatGPT</strong>: Yes</li>
<li><strong>Copilot:</strong> Yes</li>
<li><strong>Grok:</strong> Somewhat</li>
</ul></li>
<li><strong>Synthesis</strong>: Were key findings from data mining and machine learning applications well-summarized?
<ul>
<li><strong>ChatGPT:</strong> Yes</li>
<li><strong>Copilot<em>:</em></strong> Yes</li>
<li><strong>Grok-3:</strong> Yes</li>
</ul></li>
<li><strong>Trends and Gaps</strong>: Did it identify meaningful trends and research gaps?
<ul>
<li><strong>ChatGPT:</strong> There was one identified major trend, the gaps however; it was satisfactory.</li>
<li><strong>Copilot:</strong> The trends section presented general observations, and the analysis of research gaps provided greater depth.</li>
<li><strong>Grok-3</strong>: The identified trends and research gaps were meaningful but comparatively broad.</li>
</ul></li>
<li><strong>Hypothesis</strong>: Was the proposed hypothesis testable and relevant?
<ul>
<li><strong>ChatGPT:</strong> Yes</li>
<li><strong>Copilot:</strong> The proposed hypothesis is somewhat reliable, lacking the precision and specificity observed in <em>ChatGPT</em>’s output.</li>
<li><strong>Grok-3</strong>: The proposed hypothesis was reasonably well-constructed. Although the model referenced relevant sources, it did not provide formal citations, limiting verifiability.</li>
</ul></li>
<li><strong>References</strong>: Are the citations accurate (check using Google Scholar or Semantic Scholar)
<ul>
<li><strong>ChatGPT</strong>: In terms of sources, the model provided citation references, upon verification, all but one source was checked on Google Scholar and appeared academically valid.</li>
<li><strong>Copilot:</strong> The model also had a absence of citation sources or references.</li>
<li><strong>Grok-3</strong>: Although the model referenced relevant sources, it did not provide formal citations, limiting verifiability.</li>
</ul></li>
</ul></li>
<li><p><strong>Step 3: Refine the Prompt</strong></p>
<ul>
<li><p>Task: Revise the prompt to address deficiencies in each model’s response, creating three tailored prompts—one for ChatGPT, one for Copilot, and one for Grok 3.</p></li>
<li><p>Refined Prompt for All Three Models: “Imagine you’re a data scientist conducting a 2,500-word systematic literature review on how data mining and machine learning are applied in domains like healthcare, finance, and education. Outline a clear methodology, synthesize on specific key findings with fresh insights, provide a detailed and clear analysis of trends and gaps, and propose one bold, testable hypothesis. Maintain a rigorous academic tone.”</p></li>
<li><p>I test these refined prompts and compare the improved outputs.</p></li>
</ul></li>
<li><p><strong>Step 4: Cross Model Collaboration</strong></p>
<ul>
<li>Task: Integrate the best elements from each model’s output into a final systematic review. Write a new prompt for the student’s preferred model (e.g., Grok 3) to synthesize the results.</li>
<li>Example Synthesis Prompt: “Using these drafts from three AI models [pastes outputs], produce a 2,000-word structured systematic literature review on data mining and machine learning applications. Combine the strongest methodology, findings, trends, gaps, and hypothesis into a cohesive, academically sound document.”</li>
<li>I submit their final review and justify their synthesis decisions.</li>
</ul></li>
<li><p><strong>Step 5: Reflection</strong></p></li>
<li><p>Task: Write a reflection answering:</p>
<ul>
<li><p>How did each model approach the systematic review differently?</p>
<ul>
<li><p><em>ChatGPT</em>: This model produced a well-organized literature review clear methodology section and a structured consistent systematic review format. For the synthesis, the key findings related to data mining and machine learning applications was concise and well-summarized. The review identified one trend and numerous research gaps, with the discussion of gaps being particularly specific. The proposed hypothesis was both testable and relevant. In terms of sources, the model provided citation references, upon verification, all but one source was checked on Google Scholar and appeared academically valid. Overall <em>ChatGPT’s</em> response demonstrated strong specific coverages, especially in its treatment in gap areas, though the examination of trends was limited.</p></li>
<li><p><em>Copilot</em>: Similar to <em>ChatGPT</em>, this model contained a clear methodology section and systematic review format. Unlike the previous model, however, the output focused more on broader findings rather than detailed analytical synthesis. While the trends section presented general observations, the analysis of research gaps provided greater depth. The proposed hypothesis is somewhat reliable, lacking the precision and specificity observed in <em>ChatGPT</em>’s output. The model also had a absence of citation sources or references. Overall, Copilot was a coherent but less detailed literature review, with weaknesses primarily related to source support and analytical depth.</p></li>
<li><p><em>Grok 3</em>: At first, the model produced a substantially shorter review than requested, generating approximately 900 words instead of 2,500 words. After clarifying the prompt for the word count, it generated the requested output. This model contains a methodology section, although it didn’t follow a systematic review protocol. Similar to <em>ChatGPT</em>, the synthesis of key findings from data mining and machine learning applications are well-summarized, and the identified trends and research gaps were meaningful but comparatively broad. The proposed hypothesis was reasonably well-constructed. Although the model referenced relevant sources, it did not provide formal citations, limiting verifiability. Overall, Grok 3 produced a competent but lesser quality review relative to the other models.</p></li>
</ul></li>
</ul></li>
<li><p>Which prompt refinements yielded the results for each model?</p>
<ul>
<li>Regarding prompt refinements, <em>ChatGPT</em> demonstrated the best structure through its methodology and a systematic review format. In terms of the synthesis across domain, both <em>ChatGPT and Copilot</em> are equally effective, each providing balanced discussions that covered a similar range of application areas.. <em>Copilot ,</em>however, offered a more extensive discussion of trends and gaps, identifying numerous broader thematic patterns. With the respect of the hypothesis development, <em>ChatGPT</em> provided the most detailed hypothesis testing. Finally, all models generated citation references that, upon verification through <em>Google Scholar</em>, appeared to be peer-reviewed academic sources.</li>
</ul></li>
<li><p>What did you learn about leveraging AI for structured academic reviews?</p>
<ul>
<li>Through this exercise, I learned that AI isn’t the best reliable tool for writing and making structured academic literature reviews. While some AI models such as <em>ChatGPT</em> and <em>Copilot</em> can write a good academic review, their outputs may contains some flaws. For example, some models like <em>Grok-3</em> may fail to follow length or structural instructions when asked, sometimes producing outputs that is contrary from the requested format. I also learned that AI can help with citation suggestions, but it’s important to double-check the legitimacy of these citation sources through <em>Google Scholar</em> or <em>Semantic Scholar</em>. Overall, AI can be a helpful tool for brainstorming, refining writing, and checking your works and citations, but it should never be a substitute of relying on independent academic work.</li>
</ul></li>
</ul>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>